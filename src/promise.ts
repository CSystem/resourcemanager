var __promise__line = `
(function(t){function z(){for(var a=0;a<g.length;a++)g[a][0](g[a][1]);g=[];m=!1}function n(a,b){g.push([a,b]);m||(m=!0,A(z,0))}function B(a,b){function c(a){p(b,a)}function h(a){k(b,a)}try{a(c,h)}catch(d){h(d)}}function u(a){var b=a.owner,c=b.state_,b=b.data_,h=a[c];a=a.then;if("function"===typeof h){c=l;try{b=h(b)}catch(d){k(a,d)}}v(a,b)||(c===l&&p(a,b),c===q&&k(a,b))}function v(a,b){var c;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(b&&("function"===
typeof b||"object"===typeof b)){var h=b.then;if("function"===typeof h)return h.call(b,function(d){c||(c=!0,b!==d?p(a,d):w(a,d))},function(b){c||(c=!0,k(a,b))}),!0}}catch(d){return c||k(a,d),!0}return!1}function p(a,b){a!==b&&v(a,b)||w(a,b)}function w(a,b){a.state_===r&&(a.state_=x,a.data_=b,n(C,a))}function k(a,b){a.state_===r&&(a.state_=x,a.data_=b,n(D,a))}function y(a){var b=a.then_;a.then_=void 0;for(a=0;a<b.length;a++)u(b[a])}function C(a){a.state_=l;y(a)}function D(a){a.state_=q;y(a)}function e(a){if("function"!==
typeof a)throw new TypeError("Promise constructor takes a function argument");if(!1===this instanceof e)throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this.then_=[];B(a,this)}var f=t.Promise,s=f&&"resolve"in f&&"reject"in f&&"all"in f&&"race"in f&&function(){var a;new f(function(b){a=b});return"function"===typeof a}();"undefined"!==typeof exports&&exports?(exports.Promise=s?f:e,exports.Polyfill=e):"function"==
typeof define&&define.amd?define(function(){return s?f:e}):s||(t.Promise=e);var r="pending",x="sealed",l="fulfilled",q="rejected",E=function(){},A="undefined"!==typeof setImmediate?setImmediate:setTimeout,g=[],m;e.prototype={constructor:e,state_:r,then_:null,data_:void 0,then:function(a,b){var c={owner:this,then:new this.constructor(E),fulfilled:a,rejected:b};this.state_===l||this.state_===q?n(u,c):this.then_.push(c);return c.then},"catch":function(a){return this.then(null,a)}};e.all=function(a){if("[object Array]"!==
Object.prototype.toString.call(a))throw new TypeError("You must pass an array to Promise.all().");return new this(function(b,c){function h(a){e++;return function(c){d[a]=c;--e||b(d)}}for(var d=[],e=0,f=0,g;f<a.length;f++)(g=a[f])&&"function"===typeof g.then?g.then(h(f),c):d[f]=g;e||b(d)})};e.race=function(a){if("[object Array]"!==Object.prototype.toString.call(a))throw new TypeError("You must pass an array to Promise.race().");return new this(function(b,c){for(var e=0,d;e<a.length;e++)(d=a[e])&&"function"===
typeof d.then?d.then(b,c):b(d)})};e.resolve=function(a){return a&&"object"===typeof a&&a.constructor===this?a:new this(function(b){b(a)})};e.reject=function(a){return new this(function(b,c){c(a)})}})("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this);
`;
eval(__promise__line);
delete __promise__line;


declare interface PromiseTaskReporter {

    onProgress?: (current:number, total:number) => void;

    onCancel?: () => void;

}
// Generated by typings
// Source: https://raw.githubusercontent.com/typed-contrib/es2015/0.1.3/promise/index.d.ts
declare class Promise<T> implements PromiseLike<T> {
	/**
	 * When the `resolve` function is called in the body of the `executor` function passed to the constructor,
	 * the Promise is fulfilled with result object passed to `resolve`.
     *
	 * When the `reject` function is called, the promise is rejected with the `error` passed to `reject`.
	 * For consistency and debugging (eg stack traces), `error` should be an instanceof `Error`.
     * 
	 * Any errors thrown in the constructor callback will be implicitly passed to `reject`.
	 */
	constructor(executor: (resolve : (value?: T | PromiseLike<T>) => void, reject: (error?: any) => void) => void);

	/**
	 * `onFulfilled` is called when/if Promise resolves.
     * `onRejected` is called when/if Promise rejects.
     * 
	 * Both are optional, if either/both are omitted the next onFulfilled/onRejected in the chain is called.
	 * Both callbacks have a single parameter, the fulfillment value or rejection reason.
	 * 
     * `then` returns a new Promise equivalent to the value you return from onFulfilled/onRejected after being passed through Promise.resolve.
	 * If an error is thrown in the callback, the returned Promise rejects with that error.
	 *
	 * @param [onFulfilled]     called when/if Promise resolves
	 * @param [onRejected]      called when/if Promise rejects
	 */
    then<U>(onFulfilled?: (value: T) => U | PromiseLike<U>, onRejected?: (error: any) => U | PromiseLike<U>): Promise<U>;
    then<U>(onFulfilled?: (value: T) => U | PromiseLike<U>, onRejected?: (error: any) => void): Promise<U>;

	/**
	 * Sugar for promise.then(undefined, onRejected)
	 *
	 * @param [onRejected]      called when/if Promise rejects
	 */
	catch<U>(onRejected?: (error: any) => U | PromiseLike<U>): Promise<U>;
    
    /** Makes a new empty Promise. */
    static resolve(): Promise<any>;
	/** 
     * Make a new promise from the Thenable. 
     * A Thenable is Promise-like in as far as it has a `then` method. 
     */
    static resolve<T>(value?: T | PromiseLike<T>): Promise<T>;
    
    /** Make a Promise that rejects to `err`. For consistency and debugging (eg stack traces), `err` should be an instanceof Error. */
	static reject(error: any): Promise<any>;
	/** Make a Promise that rejects to `err`. For consistency and debugging (eg stack traces), `err` should be an instanceof Error. */
	static reject<T>(error: T): Promise<T>;
    
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
	static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>, T10 | PromiseLike<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>, T9 | PromiseLike<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>, T8 | PromiseLike<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3, T4, T5, T6, T7>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3, T4, T5, T6>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3, T4, T5>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>, T5 | PromiseLike<T5>]): Promise<[T1, T2, T3, T4, T5]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3, T4>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike <T4>]): Promise<[T1, T2, T3, T4]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2, T3>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T1, T2>(values: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;
	/**
	 * Make a Promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
	 * The array passed to all can be a mixture of Promise-like objects and other objects.
     * 
	 * The fulfillment value is an array (in order) of fulfillment values.
     * The rejection value is the first rejection value.
	 */
    static all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;

	/**
	 * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
	 */
	static race<T>(promises: (T | PromiseLike<T>)[]): Promise<T>;
}
